# Ten Thousand Three

## Class 08 - 1/17/24

## In this assignment we covered Python List Comprehension and Decorators. List Comprehension is a powerful tool that allows you to create new lists based on existing lists. And Decorators allow you to modify existing functions.

## Questions


**1. Python List Comprehension:**

* What is the basic syntax of Python list comprehension?
* How does it differ from using a for loop to create a list?
* Provide an example of a list comprehension that squares the elements in a given list of integers.

**Syntax:**

```python
[expression for item in iterable if condition]
```

**Key components:**

- **expression:** The value to be included in the new list, often involving the `item` variable.
- **item:** A variable representing each element from the iterable.
- **iterable:** An object you can iterate over, such as a list, tuple, or string.
- **condition:** (optional) A filter to select specific items.

**Differences from for loops:**

- **Conciseness:** List comprehensions pack list creation and modification into a single line, often making code more readable.
- **Efficiency:** Can be slightly faster than for loops due to optimizations within Python's interpreter.

**Example:**

```python
numbers = [1, 2, 3, 4, 5]
squared_numbers = [number**2 for number in numbers]  # Output: [1, 4, 9, 16, 25]
```

**2. Python Decorators:**

* What is a decorator in Python?
* Explain the concept of decorators in Python. How do they work?
* What are some common use cases for decorators?
* Provide an example of a simple decorator function.

**Concept:**

- Functions that modify the behavior of other functions without directly changing their code.
- Achieve this by wrapping the original function with new functionality.

**How they work:**

1. **Decorator creation:** Define a function that takes another function as input and returns a modified version.
2. **Function decoration:** Apply the decorator using `@decorator_name` syntax before the function definition.
3. **Calling the decorated function:** When you call the decorated function, the decorator's code executes first, then the original function's code.

**Common use cases:**

- **Logging:** Track function calls, arguments, and return values.
- **Timing:** Measure execution time of functions.
- **Authentication and authorization:** Restrict access to certain functions.
- **Caching:** Store function results to avoid redundant calculations.

**Example:**

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Function called:", func.__name__)
        result = func(*args, **kwargs)
        print("Result:", result)
        return result
    return wrapper

@my_decorator
def add(x, y):
    return x + y

add(5, 3)  # Output:
# Function called: add
# Result: 8
```

## Resources

Google Bard

[List Comprehension](https://www.pythonforbeginners.com/basics/list-comprehensions-in-python)

[Debugging](https://www.pythonpodcast.com/pysnooper-python-debugging-episode-241/)


## Bookmark

[Primer on Decorators](https://realpython.com/primer-on-python-decorators/)

## Things I want to know more about