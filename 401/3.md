# FileIO & Exceptions

## Class 03: 1/9/24

## Statement

This lesson explores file handling, reading methods, and exception handling, to provide an understanding of managing resources, file content retrieval, and error handling in Python.

## Questions

### 1. What is the purpose of the ‘with’ statement when opening a file in Python, and how does it help manage resources while reading and writing files?

The 'with' statement in Python manages resources, especially when working with files. It ensures proper handling by automatically closing files after operations within its block are completed. This prevents resource leaks and manages resources effectively.

```python
with open('example.txt', 'r') as file:
    data = file.read()
    # Perform operations with the file
# File automatically closed when exiting the 'with' block
```

### 2. Explain the difference between the ‘read()’ and ‘readline()’ methods for file objects in Python. Provide examples of when to use each method.

- `read()`: Reads the entire file content or a specified number of bytes, returning a string.
- `readline()`: Reads a single line from the file each time it's called, returning the line as a string.

Example:

```python
with open('example.txt', 'r') as file:
    content = file.read()  # Reads entire file content
    line = file.readline()  # Reads the first line
```

Use `read()` to read entire content or a specific byte count, and `readline()` to read lines one by one.

### 3. Briefly describe the concept of exception handling in Python. How can the ‘try’, ‘except’, and ‘finally’ blocks be used to handle exceptions and ensure proper execution of code? Provide a simple example.

Exception handling helps deal with errors during program execution:
- `try` block contains code that might raise an exception.
- `except` block handles the raised exception(s).
- `finally` block executes regardless of exceptions, for cleanup.

Example:
```python
try:
    # Code that might raise an exception
    result = 10 / 0  # Raises a ZeroDivisionError
except ZeroDivisionError as e:
    # Handling the specific exception
    print(f"Error: {e}")
finally:
    # Cleanup or final actions
    print("Finally block executed.")
```
This code catches a ZeroDivisionError, handles it in the except block, and executes the finally block for necessary cleanup.


## Resources

[Read & Write Files in Python](https://realpython.com/read-write-files-python/)

[Exceptions in Python](https://realpython.com/python-exceptions/)

## Bookmark

[Python Quiz](https://realpython.com/quizzes/read-write-files-python/)

## Things I want to know more about